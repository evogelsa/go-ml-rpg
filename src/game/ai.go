package game

import (
	"math"
	"math/rand"
	"reflect"
)

type Algorithm int

const (
	AI_MINMAX Algorithm = iota
	AI_RAND
	AI_NEURAL
)

// AI_ALG is set by main which uses cmd line flags to
// set the desired ai algorithm
var AI_ALG Algorithm

// normalize takes a number with values between min and
// max and normalizes it to between 0 and 1
func normalize(n, min, max float32) float32 {
	return (n - min) / (max - min)
}

func enumStates() [][]int {
	return [][]int{{0}}
}

// getState3 discretizes player stats as bad, ok, good and returns
// a 2d int slice containing these values
func getState3(p1, p2 *Class) [][]int {
	var p1I interface{} = p1
	var p2I interface{} = p2

	// get values of p1 class
	vOf1 := reflect.ValueOf(p1I).Elem()
	var sOf1 []interface{}
	for i := 2; i < vOf1.NumField(); i++ {
		// ignore player and class name, convert all to float32
		v := vOf1.Field(i).Interface()
		sOf1 = append(sOf1, v)
	}

	// get values of p2 class
	vOf2 := reflect.ValueOf(p2I).Elem()
	var sOf2 []interface{}
	for i := 2; i < vOf2.NumField(); i++ {
		// ignore player and class name, convert all to float32
		v := vOf2.Field(i).Interface()
		sOf2 = append(sOf2, v)
	}

	sOfBoth := []interface{}{sOf1, sOf2}

	states := make([][]int, 2)
	for i := 0; i < 2; i++ {
		for j := 0; j < len(sOf1); j++ {
			// check health
			if j == 0 {
				s := sOfBoth[i].([]interface{})
				h := s[j].(int)
				if h < 25 {
					states[i] = append(states[i], 0)
				} else if h < 50 {
					states[i] = append(states[i], 1)
				} else {
					states[i] = append(states[i], 2)
				}
				// check armor
			} else if j == 1 {
				s := sOfBoth[i].([]interface{})
				a := s[j].(int)
				if a < 5 {
					states[i] = append(states[i], 0)
				} else if a < 10 {
					states[i] = append(states[i], 1)
				} else {
					states[i] = append(states[i], 2)
				}
				//. check attributes
			} else {
				s := sOfBoth[i].([]interface{})
				v := s[j].(float32)
				if v < .5 {
					states[i] = append(states[i], 0)
				} else if v < .75 {
					states[i] = append(states[i], 1)
				} else {
					states[i] = append(states[i], 2)
				}
			}
		}
	}

	return states
}

// initStateAction returns float32 slice containing random initial
// values for actions between -1 and 1
func initStateAction() []float32 {
	return []float32{
		rand.Float32()*2 - 1,
		rand.Float32()*2 - 1,
		rand.Float32()*2 - 1,
		rand.Float32()*2 - 1,
		rand.Float32()*2 - 1,
		rand.Float32()*2 - 1,
	}
}

// enumStateSimple3 returns a q table map of state byte to float32 slice generated by
// looking at three discrete values derived from health, armor, and class
func enumStateSimple3() map[uint16][]float32 {
	qTable := make(map[uint16][]float32)
	for h1 := 0; h1 <= 2; h1++ {
		for a1 := 0; a1 <= 2; a1++ {
			for c1 := 0; c1 <= 2; c1++ {
				for h2 := 0; h2 <= 2; h2++ {
					for a2 := 0; a2 <= 2; a2++ {
						for c2 := 0; c2 <= 2; c2++ {
							state := uint16((h1 << 10) + (a1 << 8) + (c1 << 6) +
								(h2 << 4) + (a2 << 2) + c2)
							qTable[state] = initStateAction()
						}
					}
				}
			}
		}
	}

	return qTable
}

func getStateSimple3(p, e *Class) uint16 {
	var state uint16

	switch p.ClassName {
	case "Knight":
		state += 0 << 10
	case "Archer":
		state += 1 << 10
	case "Wizard":
		state += 2 << 10
	}

	if p.Health < 25 {
		state += 0 << 8
	} else if p.Health < 50 {
		state += 1 << 8
	} else {
		state += 2 << 8
	}

	if p.Armor < 5 {
		state += 0 << 6
	} else if p.Armor < 10 {
		state += 1 << 6
	} else {
		state += 2 << 6
	}

	switch e.ClassName {
	case "Knight":
		state += 0 << 4
	case "Archer":
		state += 1 << 4
	case "Wizard":
		state += 2 << 4
	}

	if e.Health < 25 {
		state += 0 << 2
	} else if e.Health < 50 {
		state += 1 << 2
	} else {
		state += 2 << 2
	}

	if e.Armor < 5 {
		state += 0
	} else if e.Armor < 10 {
		state += 1
	} else {
		state += 2
	}

	return state
}

// minMaxDamage returns array of avg outcome for each move wrt
// damage dealt to player
func minMaxDamage(p, e *Class) []float32 {
	// actions: heavy, quick, standard, block, parry, evade
	// calculate average damage to player of each attack
	// chance of success * avg outcome = avg val
	avgH := (1 - p.Intellect) * float32(int(10*e.Strength+1.5))
	avgQ := (1 - p.Strength) * float32(int(10*e.Dexterity+1.5))
	avgS := (1 - p.Dexterity) * float32(int(10*e.Intellect+1.5))
	avgB := float32(0)
	avgP := (e.Dexterity) * float32(int(10*e.Dexterity+.5))
	avgE := float32(0)

	return []float32{avgH, avgQ, avgS, avgB, avgP, avgE}
}

// minMaxHealth returns array of avg outcome for each move wrt
// change in enemy health
func minMaxHealth(p, e *Class) []float32 {
	avgsFromPlayer := minMaxDamage(e, p)
	var avgPlayer float32
	for _, v := range avgsFromPlayer {
		avgPlayer += v
	}
	avgPlayer /= 6

	avgH := -avgPlayer
	avgQ := -avgPlayer
	avgS := -avgPlayer
	// enemy fail block prob * avg damage
	avgB := ((1 - e.Strength) * avgPlayer)
	// enemy fail parry prob * extra dmg + avg damage
	avgP := -(((1 - e.Dexterity) * float32(int(10*e.Dexterity+.5))) + avgPlayer)
	// enemy evade prob * heal - enemy fail evade prob * avg damage
	avgE := ((e.Intellect) * float32(int(10*e.Intellect+.5))) -
		((1 - e.Intellect) * avgPlayer)

	return []float32{avgH, avgQ, avgS, avgB, avgP, avgE}
}

// min/maxArmor gets avg outcome for each move wrt to change in
// enemy armor
func minMaxArmor(p, e *Class) []float32 {
	avgsFromPlayer := minMaxDamage(e, p)
	var avgPlayer float32
	for _, v := range avgsFromPlayer {
		avgPlayer += v
	}
	avgPlayer /= 6

	avgH := -avgPlayer
	avgQ := -avgPlayer
	avgS := -avgPlayer
	// enemy block prob * avg heal - enemy fail block prob * avg damage
	avgB := (((e.Strength) * float32(int(10*e.Strength+.5))) -
		((1 - e.Strength) * avgPlayer))
	// enemy fail parry prob * extra dmg + avg damage
	avgP := -(((1 - e.Dexterity) * float32(int(10*e.Dexterity+.5))) + avgPlayer)
	// enemy fail evade prob * avg damage
	avgE := -((1 - e.Intellect) * avgPlayer)

	return []float32{avgH, avgQ, avgS, avgB, avgP, avgE}
}

// getMinMaxAll calls the three minmax funcs and returns array containing
// all of the results.
func getMinMaxAll(p, e *Class) [][]float32 {
	return [][]float32{
		minMaxDamage(p, e),
		minMaxHealth(p, e),
		minMaxArmor(p, e),
	}
}

// normalizedMinMaxes returns a normalized slice containing weights
// for each move, sums to 1
func normalizedMinMaxes(p, e *Class) []float32 {
	minMaxes := getMinMaxAll(p, e)

	var max float32 = -math.MaxFloat32
	for _, mm := range minMaxes {
		for _, v := range mm {
			if v > max {
				max = v
			}
		}
	}

	var min float32 = math.MaxFloat32
	for _, mm := range minMaxes {
		for _, v := range mm {
			if v < min {
				min = v
			}
		}
	}

	for i, mm := range minMaxes {
		for j := range mm {
			minMaxes[i][j] = normalize(minMaxes[i][j], min, max)
		}
	}

	var sum float32
	for _, mm := range minMaxes {
		for _, v := range mm {
			sum += v
		}
	}

	for i, mm := range minMaxes {
		for j := range mm {
			minMaxes[i][j] = normalize(minMaxes[i][j], 0, sum)
		}
	}

	var vals []float32
	for _, r := range minMaxes {
		vals = append(vals, r...)
	}

	for i := 6; i < len(vals); i++ {
		vals[i%6] += vals[i]
	}

	var ret []float32 = vals[:6]

	return ret
}

// getTurnMinMax uses the minmax strategy to determine weighted probabilities
// for each move and pseudorandomly selects the move to use based on weights
func getTurnMinMax(p, e *Class) Move {
	minMaxes := normalizedMinMaxes(p, e)

	r := rand.Float32()
	var m int
	for i, v := range minMaxes {
		r -= v
		if r <= 0 {
			m = i
			break
		}
	}
	return Move(m)
}

// getTurnRand randomly selects a move to use
func getTurnRand(p, e *Class) Move {
	return Move(rand.Intn(6))
}

// aiGetTurn handles getting the next move of the AI using whatever strategy was
// selected at server launch
func AIGetTurn(p, e *Class) Move {
	var m Move

	switch AI_ALG {
	case AI_MINMAX:
		m = getTurnMinMax(p, e)
	case AI_RAND:
		m = getTurnRand(p, e)
	}

	return m
}
